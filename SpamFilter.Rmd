---
title: "Filtering Spam Emails via Classification Tree-Based Models"
author: "Andy Nguyen, Michael Wolfe, Joseph Caguioa"
date: "6/10/2020"
output: html_document
---

```{R setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(knitr)
library(kableExtra)
library(pastecs)
library(rpart)
```

## Project Guidelines

Using the “emailDFrp” dataset:

1.	Build and evaluate a tree-based model for predicting “spam”
2.	Plot and analyze the paths through one (or many) of your trees
3.	Explain the parameters involved in “tuning” your model
4.	Which variables were “most” important?
5.	How did you evaluate the “performance” of your model?

NOTE: You should use “split” your data when training your model.

## Objective
Most spam messages can usually be identified in a person's email list through the subject line and sender, but may occassionally require a glimpse of the message contents to provide a more conclusive approach. Spam filters examine these various characteristics of an email before classifying the message and placing it into the inbox of spam folder. 

In this study, a classification tree-based model will be built to predict whether an email message is spam (unwanted) or not spam (wanted) through recursive partitioning.
<br>
<br>

## Data Description
The model will be built using data from the open-source [Apache SpamAssassin Project](https://spamassassin.apache.org/) that contains over 9000 labeled email messages for the purposes of developing spam filters. The original data from the SpamAssassin corpus is in text format and must be processed to quantify the information into a useful format. 


<figure class ="image">
<center>
    <img src = "SpamAssassin+HomePage.png">
    <figcaption id = "Figure 1"> **Figure 1: Apache SpamAssassin Home Page** </figcaption>
</center>
</figure>
<br>
<br>

An email can be separated into the header and the body. The header contains information regarding the date sent, the sender, the subject, the message ID, carbon copy recipients, and additional routing information. This can be understood as the encasing envelope for the message. The body can understood as the actual letter that contains the intended message for the recipient and may contain additional information beyond text such as file attachments.

A number of text mining and statistical analysis approaches can be taken to derive meaningful features from email messages. Such features are the character count within the body content of the email, the number of accompanying file attachments, and wheter "Re:" appears at the start of the subject to denote a reply. In this study, a pre-processed format of the data was provided so the specific details regarding the data processing steps will not be explained further.

```{R load email data}
# Load Data (data.Rda file needs to be in same directory as markdown)
emilDFrp = load("data.Rda")
# Cast data as data frame
emails = data.frame(emailDFrp)

# Display first and last 10 processed emails from data frame
kable(head(emails, n=10), caption = "First 10 Process Emails") %>%
  kable_styling(bootstrap_options = c("striped","hover","responsive")) %>%
  scroll_box(width = "100%", height = "465px")
kable(tail(emails, n=10), caption = "Last 10 Processed Emails") %>%
  kable_styling(bootstrap_options = c("striped","hover","responsive")) %>%
  scroll_box(width = "100%", height = "470px")
```

```{R Summary Statistics}
# Display Internal Structure of Data
str(emails)
# Display Summary Statistics of Boolean Data Columns
kable(summary(emails[,1:17])) %>%
  kable_styling(bootstrap_options = c("striped","responsive")) %>%
  scroll_box(width = "100%", height = "185px")
# Display Summary Statistics of Numerical Data Columns
kable(stat.desc(emails[,18:30])) %>%
  kable_styling(bootstrap_options = c("striped","responsive")) %>%
  scroll_box(width = "100%", height = "575px")
```

## Tree Model
```{R Tree Model}
set.seed(567)
n = nrow(emails)
train = sort(sample(1:n, floor(n/2)))

email.train = emails[train,]
email.test = emails[-train,]

email.rp = rpart(isSpam ~ . ,                         
                data = emails,                       
                subset = train,                       
                method = "class",                     
                parms = list(split = "information"),  
                maxsurrogate = 0,                     
                cp = 0,                               
                minsplit = 5,                         
                minbucket = 2)

summary(email.rp)
plot(email.rp, 
     uniform=TRUE,
     compress=TRUE,
     margin = .2)
text(email.rp, 
     use.n=TRUE, 
     all = TRUE,
     fancy = TRUE)


colours = apply(matrix(emails[,"isSpam"]), 
                 1,
                 function(x){if (x=="Setosa") 
                   1 else 
                     if (x == "Versicolor")
                       2 else 3}
)

colours <-  c("red", "green3", "blue")[colours]

plot(iris.df[train,"PetalWidth"],iris.df[train,"PetalLength"], 
     col = colours[train], main = "Recursive partitoning regions")
lines(x=c(0,2.5), y = c(2.45,2.45), lty = 1)
lines(x=c(1.65,1.65), y = c(2.45,7), lty = 2)
lines(x=c(0,1.65), y = c(4.96,4.95), lty = 3)


pred.rp = predict(email.rp,
                   newdata = emailS[-train,],
                   type = "class")
pred.rp

predict(email.rp, 
        newdata = emails[-train,],
        type = "prob")

predict(email.rp, 
        newdata = emails[-train,],
        type = "vector")

predict(email.rp, 
        newdata = emails[-train,],
        type = "matrix")


table(emails$isSpam[-train], pred.rp)

printcp(email.rp)
plotcp(email.rp)

email.rp <- prune(email.rp, cp = 0.1)

plot(email.rp, 
     compress=TRUE,
     margin = .2)
text(email.rp, 
     use.n=TRUE, 
     all = TRUE,
     fancy = TRUE)
```