---
title: "Filtering Spam Emails via Classification Tree-Based Models"
author: "Andy Nguyen, Michael Wolfe, Joseph Caguioa"
date: "6/10/2020"
output: html_document
---

```{R setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(knitr)
library(kableExtra)
library(pastecs)
library(rpart)
library(ggplot2)
library(itertools)
library(tidyr)
library(dplyr)
library(PerformanceAnalytics)
```

## Project Guidelines

Using the “emailDFrp” dataset:

1.	Build and evaluate a tree-based model for predicting “spam”
2.	Plot and analyze the paths through one (or many) of your trees
3.	Explain the parameters involved in “tuning” your model
4.	Which variables were “most” important?
5.	How did you evaluate the “performance” of your model?

NOTE: You should use “split” your data when training your model.

## Objective
Most spam messages can usually be identified in a person's email list through the subject line and sender, but may occassionally require a glimpse of the message contents to provide a more conclusive approach. Spam filters examine these various characteristics of an email before classifying the message and placing it into the inbox of spam folder. 

In this study, a classification tree-based model will be built to predict whether an email message is spam (unwanted) or not spam (wanted) through recursive partitioning.
<br>
<br>

## Data Description
The model will be built using data from the open-source [Apache SpamAssassin Project](https://spamassassin.apache.org/) that contains over 9000 labeled email messages for the purposes of developing spam filters. The original data from the SpamAssassin corpus is in text format and must be processed to quantify the information into a useful format. 


<figure class ="image">
<center>
    <img src = "SpamAssassin+HomePage.png">
    <figcaption id = "Figure 1"> **Figure 1: Apache SpamAssassin Home Page** </figcaption>
</center>
</figure>
<br>
<br>

An email can be separated into the header and the body. The header contains information regarding the date sent, the sender, the subject, the message ID, carbon copy recipients, and additional routing information. This can be understood as the encasing envelope for the message. The body can understood as the actual letter that contains the intended message for the recipient and may contain additional information beyond text such as file attachments.

A number of text mining and statistical analysis approaches can be taken to derive meaningful features from email messages. Such features are the character count within the body content of the email, the number of accompanying file attachments, and wheter "Re:" appears at the start of the subject to denote a reply. In this study, a pre-processed format of the data was provided so the specific details regarding the data processing steps will not be explained further.

```{R load email data}
# Load Data (data.Rda file needs to be in same directory as markdown)
emilDFrp = load("data.Rda")
# Cast data as data frame
emails = data.frame(emailDFrp)

# Display first and last 10 processed emails from data frame
kable(head(emails, n=10), caption = "Table 1: First 10 Process Emails") %>%
  kable_styling(bootstrap_options = c("striped","hover","responsive")) %>%
  scroll_box(width = "100%", height = "465px")
kable(tail(emails, n=10), caption = "Table 2: Last 10 Processed Emails") %>%
  kable_styling(bootstrap_options = c("striped","hover","responsive")) %>%
  scroll_box(width = "100%", height = "470px")

# Display Internal Structure of Data Frame
str(emails)
```
<br>

The first and last 10 messages from the processed emails data are provided above respectively in Table 1 and 2. The first 10 messages are a sample of 10 emails that are labled as not spam and the last 10 messages are a sample of 10 emails that are labeled as spam. The structure of the processed emails dataframe containing a total of 9,348 messages and 30 feature variables is also displayed above. The first 17 features are categorical variables with 2 levels each denoting a boolean value of whether or not the message contains that certain feature. The first feature (isSpam) is the target variable labeling whether or not the email was identified as spam. The last 13 features are numerical variables describing various attributes of the message such as length and number of punctuations present. A full, detailed explanation of each feature in the processed emails dataframe is provided below in Table 3. 

<br>

|   Variable      |      Type    |                                      Definition                                          |
|:--------------- |:------------:|-----------------------------------------------------------------------------------------:|
|isSpam           |logical       |TRUE if email message is spam (target variable).                                          |
|isRe             |logical       |TRUE if "Re:" appears at the start of the subject.                                        |
|numLines         |integer       |Number of lines in the body of the message.                                               | 
|bodyCharCt       |integer       |Number of characters in the body of the message.                                          |
|underscore       |logical       |TRUE if email address in the FROM field of the header contains an underscore.             |
|subExcCt         |integer       |Number of exclamation marks in the subject.                                               |
|subQuesCt        |integer       |Number of question marks in the subject.                                                  |
|numAtt           |integer       |Number of attachments in the message.                                                     |
|priority         |logical       |TRUE if a Priority key is present in the header.                                          |
|numRec           |numeric       |Number of recipients of the message, including CCs.                                       |
|perCaps          |numeric       |Percentage of capitals among all letters in the message body, excluding attachments.      |
|isInReplyTo      |logical       |TRUE if the In-Reply-To key is present in the header.                                     |
|sortedRec        |logical       |TRUE if the recipients' email addresses are sorted.                                       |
|subPunc          |logical       |TRUE if words in the subject have punctuation or numbers embedded in them. (e.g. w!se)    |
|hour             |numeric       |Hour of the day in the Date field.                                                        |
|multipartText    |logical       |TRUE if the MIME type is multipart/text.                                                  |
|hasImages        |logical       |TRUE if the message contains images.                                                      |
|isPGPsigned      |logical       |TRUE if the message contains a PGP signature.                                             |
|perHtML          |numeric       |Percentage of characters in HTML tags in the message body in comparison to all characters.|
|subSpamWords     |logical       |TRUE if the subject contains one of the words in a spam word vector.                      |
|subBlanks        |numeric       |Percentage of blanks in the subject.                                                      |
|noHost           |logical       |TRUE if there is no hostname in the Message-Id key in the header.                         |
|numEnd           |logical       |TRUE if the email sender's address (before the @) ends in a number.                       |
|isYelling        |logical       |TRUE if the subject is all capital letters.                                               |
|forwards         |numeric       |Number of forward symbols in a line of the body. (e.g. >>> xxx contains 3 forwards)       |
|isOrigMsg        |logical       |TRUE if the message body contains the phrase original message.                            |
|isDear           |logical       |TRUE if the message body contains the word "dear".                                        |
|isWrote          |logical       |TRUE if the message contains the phrase "wrote:".                                         |
|avgWordLen       |numeric       |The average length of the words in  a message.                                            |
|numDlr           |numeric       |Number of dollar signs in the message body.                                               |

Table: Table 3: Variable Definition Table

<br>

### Summary Statistics 

The plot shown below in Figure 2 visualizes the class label (True or False) distributions for each of the 17 discrete, categorical variables in the processed emails dataframe, including the target variable "isSpam". Most features are predominately labeled False, indicating that the majority of emails do not contain the described attribute in the message. The only feature with more TRUE values is the "sortedRec" variable, meaning that nearly 90% of emails in the data sort the recipienets' email addresses. 

Most importantly, this figure provides the target variable's stratification levels for the validation scheme when training the classification tree model due to the class imbalance. When holding out a split of the data for testing model performance, the sample will be composed of roughly 25.6% spam emails and 74.4% non-spam emails to ensure that the split is representative of the data as a whole.
<br>

```{R Categorical Variables Visualization, fig.align = "center", fig.width = 11.5, fig.height = 6}
# Initialize an empty dataframe
TFcounts = data.frame(FeatureVariables = character(), TFcounts = integer(), total = integer())
for (col in as.list(enumerate(colnames(emails[,1:17])))){
  #print(col$index)
  #print(col$value)
  TFcounts = rbind(TFcounts, data.frame(FeatureVariables=col$value, TFcounts=table(emails[,col$index]), total=sum(table(emails[,col$index]))))
}
TFcounts$labelpos = ifelse(TFcounts$TFcounts.Var1=="F", (1-(TFcounts$TFcounts.Freq/TFcounts$total))+((TFcounts$TFcounts.Freq/TFcounts$total)/2), 
(TFcounts$TFcounts.Freq/TFcounts$total)/2)

ggplot(data = TFcounts, aes(x = FeatureVariables, y = TFcounts.Freq, fill = TFcounts.Var1)) +
  geom_bar(position="fill", stat = "identity", color="black", width=1.0) +
  scale_y_continuous(labels = scales::percent) +
  geom_text(aes(label = paste0(round((TFcounts.Freq/total)*100,1),"%"),y=labelpos), size = 4) +
labs(title="Percentage of True/False Values per Categorical Variable", x="Categorical Feature Variable", y="Percentage of Values", fill="Class Labels", caption="Figure 2: Plot of Class Label Distribution per Categorical Feature Variable") + 
  theme(plot.title=element_text(size=12, hjust=0.5), plot.caption=element_text(size=11, hjust=0.5), legend.position="top", axis.text.x=element_text(angle=30, hjust=1))
```

The following plot shown below in Figure 3 visualizes the distribution of data points for continuous feature variables in the processed emails data frame. These features have average values below 25 with roughly half the variables having average values around 0. The distribution of the "forwards", "numRec", "perCaps", "perHTML", and "subBlanks" variables also present long right tails; as can be seen with the accumulation of black dots extending past the box (75th percentile) and towards values of 100.

For the features listed in Figure 3, there appears to be only one potential outlier email present with a value greater than 300 for the number of recipients. However, this outlier should not be considered as an error since intuition suggests that this email would most likely be spam due to an usually large number of intended recipients. A quick search for this outlier email verifies that it is a spam message, and further suggests that a higher number of recipients may be correlated with a spam email.

<br>

``` {R Box Plot Visualization, fig.align = "center", fig.width = 11.5, fig.height = 6}
emails[,20:29] %>% 
  pivot_longer(., cols = colnames(emails[,20:29]), names_to = "FeatureVariables", values_to = "Val") %>%
  ggplot(aes(x = FeatureVariables, y = Val)) +
  geom_boxplot() +
  labs(title = "Data Distribution per Continuous Feature Variable", x = "Continuous Feature Variable", y = "Data Values", caption = "Figure 3: Plot of Data Distribution per Continuous Feature Variable") +
  theme(plot.title = element_text(size=12, hjust=0.5), plot.caption = element_text(size=11, hjust=0.5))
```
<br>
<br>

The last 3 continuous variables are visualized in a correlation matrix due to the longer right tails in their data distributions. There appears to be outliers present in each of these variables with an email having roughly 6000 lines for numLines, roughly 190000 characters for bodyCharCt, and roughly 2000 dollar signs for numDlr. The outliers for numLines and bodyCharCt do not seem to be errors since their is no maximum text length restriction for emails sent. The large number of dollar signs does seem out of the ordinary, but may be context specific regarding finances. The decision on how to handle this outlier will be further examined when building the model and evaluating if its inclusion affects performance.

Furthermore, this figure indicates an extremely high correlation between the numLines and bodyCharCt since both of these features are measurements of message length. The inclusion of both these variables will be further evaluated in model building to evaluate their effects on performance. Note: bodyCharCt seems to be a more informative measurement of message length.

```{R Correlation Matrix, fig.align = "center", fig.caption = "Figure 4: Correlation Matrix of numLines, bodyChartCt, numDlr"}
chart.Correlation(emails[,c(18:19,30)], histogram=TRUE)
```

### Train Test Split

```{R Train Test Split}
set.seed(567)
n = nrow(emails)
train = sort(sample(1:n, floor(n/2)))

emails.train = emails[train,]
emails.test = emails[-train,]
```


### Impute Missing Values
The processed emails dataframe has 7 feature that contain missing values: subSpamWords has 7, noHost has 1, isYelling has 7, subExcCt has 20, subQuesCt has 20, and subBlanks has 20. The "numRec" feature has an overwhelmingly larger amount of missing values with 282, as highlighted below in red within Figure 5.

The imputation methods will be made following a training-test split to prevent data leakage. The categorical variables ["subSpamWords", "noHost", "isYelling"] will be imputed via probability based on the distribution frequency of the class labels. The continuous variables will be imputed based on the average/median value of the data points within that respective feature.

```{R Visualize Missing Values, fig.align = "center"}
# Initialize an empty data frame
missCols = data.frame(FeatureVariables = character(), MissingValues = integer())
for (col in as.list(enumerate(colnames(emails)))){
  missVals = sum(is.na(emails[,col$index]))
  if (missVals > 0) {
    #rbind(missCols, as.list(c(col$value,missVals)))
    missCols = rbind(missCols, data.frame(FeatureVariables = col$value, MissingValues = missVals))
  }
}

ggplot(data = missCols, aes(x=FeatureVariables, y=MissingValues, fill=factor(ifelse(MissingValues>20,"yes","no")))) + 
  geom_bar(stat = "identity") + 
  scale_fill_manual(values = c("yes"="red","no"="grey"), guide = FALSE) +
  labs(title = "Number of Missing Values per Feature Variable", x = "Feature Variable", y = "Missing Values", caption = "Figure 5: Plot of Missing Values per Feature Variable") + 
  theme(plot.title = element_text(size=12, hjust=0.5), plot.caption = element_text(size=11, hjust=0.5))
```

```{R Imputation}
#function to fill categorical variables
fill_categorical_sample = function(x) {
    x_na = is.na(x)
    x[x_na] = sample(x[!x_na], size = sum(x_na), replace = TRUE)
    return(x)
}

#Continuous Variables in Training set
emails.train$subExcCt = ifelse(is.na(emails.train$subExcCt), mean(emails.train$subExcCt,na.rm=T), emails.train$subExcCt)
emails.train$subQuesCt = ifelse(is.na(emails.train$subQuesCt), mean(emails.train$subQuesCt,na.rm=T), emails.train$subQuesCt)
emails.train$subBlanks = ifelse(is.na(emails.train$subBlanks), mean(emails.train$subBlanks,na.rm=T), emails.train$subBlanks)
emails.train$numRec = ifelse(is.na(emails.train$numRec), mean(emails.train$numRec,na.rm=T), emails.train$numRec)

#Categorical Variables in Training set
#set(emails.train, subSpamWords, fill_categorical_sample(subSpamWords), by = isSpam)
#emails.train[, subSpamWords := fill_categorical_sample(subSpamWords), by = isSpam]
#emails.train[, noHost := fill_categorical_sample(noHost), by=isSpam]
#emails.train[, isYelling := fill_categorical_sample(isYelling), by=isSpam]

#Continuous Variables in Test set
emails.test$subExcCt = ifelse(is.na(emails.test$subExcCt), mean(emails.test$subExcCt,na.rm=T), emails.test$subExcCt)
emails.test$subQuesCt = ifelse(is.na(emails.test$subQuesCt), mean(emails.test$subQuesCt,na.rm=T), emails.test$subQuesCt)
emails.test$subBlanks = ifelse(is.na(emails.test$subBlanks), mean(emails.test$subBlanks,na.rm=T), emails.test$subBlanks)
emails.test$numRec = ifelse(is.na(emails.test$numRec), mean(emails.test$numRec,na.rm=T), emails.test$numRec)

#Categorical Variables in Test set
#emails.test[, subSpamWords := fill_categorical_sample(subSpamWords), by=isSpam]
#emails.test[, noHost := fill_categorical_sample(noHost), by=isSpam]
#emails.test[, isYelling := fill_categorical_sample(isYelling), by=isSpam]

```

### Tree Based Model

```{R Tree Model, fig.align = "center"}
emails.rp = rpart(isSpam ~ . , data = emails, subset = train, method = "class", parms = list(split = "information"), maxsurrogate = 0, cp = 0, minsplit = 5, minbucket = 2)
summary(emails.rp)
plot(emails.rp, uniform=TRUE, compress=TRUE, margin = .2)
text(emails.rp, use.n=TRUE, all = TRUE, fancy = TRUE)
```


```{R Plot Tree Model, fig.align = "center"}
colours = apply(matrix(emails[,"isSpam"]), 
                 1,
                 function(x){if (x=="Setosa") 
                   1 else 
                     if (x == "Versicolor")
                       2 else 3}
)

colours <-  c("red", "green3", "blue")[colours]

plot(emails[train,"numLines"],emails[train,"bodyCharCt"], 
     col = colours[train], main = "Recursive partitoning regions")
lines(x=c(0,2.5), y = c(2.45,2.45), lty = 1)
lines(x=c(1.65,1.65), y = c(2.45,7), lty = 2)
lines(x=c(0,1.65), y = c(4.96,4.95), lty = 3)
```

```{R Predict Tree Model, fig.align = "center"}
pred.rp = predict(emails.rp,
                   newdata = emails[-train,],
                   type = "class")
pred.rp

predict(emails.rp, 
        newdata = emails[-train,],
        type = "prob")

predict(emails.rp, 
        newdata = emails[-train,],
        type = "vector")

predict(emails.rp, 
        newdata = emails[-train,],
        type = "matrix")


table(emails$isSpam[-train], pred.rp)

printcp(emails.rp)
plotcp(emails.rp)
```

```{R Prune Tree Model, fig.align = "center"}
emails.rp <- prune(emails.rp, cp = 0.1)

plot(emails.rp, 
     compress=TRUE,
     margin = .2)
text(emails.rp, 
     use.n=TRUE, 
     all = TRUE,
     fancy = TRUE)
```

### Appendix
```{R Summary Statistics}
# Display Summary Statistics of Numerical Data Columns
kable(stat.desc(emails[,18:30]), caption = "Table 4: Summary Statistics of Numerical Variables") %>%
  kable_styling(bootstrap_options = c("striped","responsive")) %>%
  scroll_box(width = "100%", height = "607px")
# Display Summary Statistics of Boolean Data Columns
kable(summary(emails[,1:17]), caption = "Table 5: Summary Statistics of Categorical Variables") %>%
  kable_styling(bootstrap_options = c("striped","responsive")) %>%
  scroll_box(width = "100%", height = "220px")
```

```{R Additional BoxPlots}
emails[,c(18:19,30)] %>% 
  pivot_longer(., cols = colnames(emails[,c(18:19,30)]), names_to = "FeatureVariables", values_to = "Val") %>%
  ggplot(aes(x = FeatureVariables, y = Val)) +
  geom_boxplot() +
  labs(title = "Data Distribution", x = "Continuous Feature Variable", y = "Data Values", caption = "Figure 4: Plot of Data Distribution for numLines, bodyCharCt, numDlr") +
  theme(plot.title = element_text(size=12, hjust=0.5), plot.caption = element_text(size=11, hjust=0.5))
```